import { Meta } from '@storybook/blocks';

<Meta title="Testing/Testing Guide" />

# Testing Guide

Complete guide to testing components in the Ozean Licht ecosystem Storybook implementation.

## Overview

Our testing strategy consists of three complementary approaches:

1. **Unit Tests with Vitest** - Smoke tests and component logic validation
2. **Visual Regression with Chromatic** - Automated visual testing
3. **Accessibility Audits** - Automated WCAG 2.1 AA compliance checks

---

## 1. Unit Testing with Vitest

### Portable Story Tests

We use **portable stories** to test Storybook stories directly in Vitest. This ensures that stories render correctly and maintains a single source of truth.

### Running Tests

```bash
# Run all tests
npm test

# Run tests in watch mode
npm test -- --watch

# Run tests with UI
npm run test:ui

# Generate coverage report
npm run test:coverage
```

### Writing Portable Story Tests

#### Example: Button Component Test

```tsx
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { composeStories } from '@storybook/react';
import * as stories from './Button.stories';

// Compose all stories
const { Primary, Disabled, Loading } = composeStories(stories);

describe('Button Component', () => {
  it('renders primary button', () => {
    render(<Primary />);
    expect(screen.getByRole('button')).toBeInTheDocument();
  });

  it('disables correctly', () => {
    render(<Disabled />);
    expect(screen.getByRole('button')).toBeDisabled();
  });

  it('shows loading state', () => {
    render(<Loading />);
    expect(screen.getByRole('button')).toHaveTextContent(/processing/i);
  });
});
```

### Test Categories

#### 1. Smoke Tests (Required)

Every story should have a smoke test verifying it renders without errors.

```tsx
it('renders the default story', () => {
  render(<Default />);
  expect(screen.getByRole('button')).toBeInTheDocument();
});
```

#### 2. State Tests

Test different component states (disabled, loading, error, etc.)

```tsx
it('renders disabled state', () => {
  render(<Disabled />);
  expect(screen.getByRole('button')).toBeDisabled();
});
```

#### 3. Interaction Tests

Test user interactions using Testing Library utilities.

```tsx
import { userEvent } from '@testing-library/user-event';

it('handles click events', async () => {
  const user = userEvent.setup();
  render(<Interactive />);
  const button = screen.getByRole('button');
  await user.click(button);
  // Assert expected behavior
});
```

#### 4. Args Validation Tests

Verify story args are correctly configured.

```tsx
it('primary story has correct variant', () => {
  expect(Primary.args?.variant).toBe('primary');
});
```

### Test Structure Best Practices

```tsx
describe('ComponentName', () => {
  describe('Smoke Tests - Rendering', () => {
    // Basic rendering tests
  });

  describe('State Tests', () => {
    // Different component states
  });

  describe('Interaction Tests', () => {
    // User interactions
  });

  describe('Accessibility', () => {
    // A11y specific tests
  });
});
```

---

## 2. Visual Regression Testing with Chromatic

### Overview

Chromatic automatically captures snapshots of all stories and detects visual changes across browsers.

### Features

- **TurboSnap**: Git-aware diffing - only tests changed components (80% cost reduction)
- **Multi-browser**: Chrome, Firefox, Safari, Edge
- **CI/CD Integration**: Automatic PR checks
- **UI Review**: Review visual changes in Chromatic dashboard

### Workflow

1. **Push changes** to GitHub
2. **GitHub Actions** triggers Chromatic build
3. **Snapshots** are captured for all stories
4. **Visual diff** is generated comparing to baseline
5. **Review changes** in Chromatic dashboard
6. **Accept or reject** visual changes

### Running Chromatic Locally

```bash
# Requires CHROMATIC_PROJECT_TOKEN environment variable
npm run chromatic
```

### GitHub Actions Integration

Visual regression tests run automatically on every PR via `.github/workflows/chromatic.yml`.

**Configuration:**
- **TurboSnap**: Enabled (only tests changed stories)
- **Auto-accept**: Main branch changes auto-accepted
- **Exit on changes**: Doesn't fail build on visual changes

### Best Practices

1. **Consistent snapshots**: Use `chromatic.delay` parameter for animations
2. **Ignore dynamic content**: Use `chromatic.disableSnapshot` for dynamic stories
3. **Baseline management**: Accept legitimate changes promptly

Example story configuration:

```tsx
export const AnimatedCard: Story = {
  parameters: {
    chromatic: {
      delay: 300, // Wait for animation to complete
      pauseAnimationAtEnd: true,
    },
  },
};

export const DynamicContent: Story = {
  parameters: {
    chromatic: {
      disableSnapshot: true, // Skip snapshot for this story
    },
  },
};
```

---

## 3. Accessibility Testing

### Automated Checks

All stories are automatically tested for **WCAG 2.1 AA** compliance using the **@storybook/addon-a11y**.

### Accessibility Panel

Open the **Accessibility** tab in Storybook to see:
- ✅ **Passes**: Accessibility checks that passed
- ❌ **Violations**: Issues that must be fixed
- ⚠️ **Incomplete**: Checks requiring manual verification

### Enabled Rules

Our configuration checks for:

**Critical Rules:**
- Color contrast (WCAG AA: 4.5:1 for text)
- ARIA attributes (required, valid)
- Button/link naming
- Form labels
- Language attributes

**Keyboard Navigation:**
- Focus order
- Tab index usage

**Screen Reader Support:**
- ARIA hidden elements
- Valid ARIA attributes

**Semantic HTML:**
- Proper landmark usage
- Heading hierarchy
- Main content region

### Manual Accessibility Checks

Some checks cannot be automated and require manual testing:

#### 1. Keyboard Navigation
- ✅ All interactive elements are keyboard accessible
- ✅ Logical tab order
- ✅ Visible focus indicators
- ✅ No keyboard traps

#### 2. Screen Reader Compatibility
- ✅ Test with NVDA (Windows) or VoiceOver (Mac)
- ✅ All content is announced correctly
- ✅ Interactive elements have descriptive labels

#### 3. Focus Management
- ✅ Focus moves logically after actions (modals, etc.)
- ✅ Focus returns to trigger after closing dialogs

#### 4. Touch Target Size
- ✅ Minimum 44×44px touch targets (WCAG 2.5.5)

### Accessibility Testing Checklist

Before marking a component as complete:

```markdown
- [ ] All automated a11y checks pass
- [ ] Color contrast meets WCAG AA (4.5:1 text, 3:1 UI)
- [ ] Keyboard navigation works correctly
- [ ] Focus indicators are visible
- [ ] ARIA labels are descriptive
- [ ] Semantic HTML is used
- [ ] Tested with screen reader (if applicable)
- [ ] Touch targets are adequate size
```

### Fixing Common A11y Issues

#### Low Color Contrast

```tsx
// ❌ Bad: Insufficient contrast
<button className="bg-primary-300 text-white">Click</button>

// ✅ Good: Sufficient contrast
<button className="bg-primary-500 text-white">Click</button>
```

#### Missing Button Labels

```tsx
// ❌ Bad: Icon button without label
<button><CloseIcon /></button>

// ✅ Good: Accessible label provided
<button aria-label="Close dialog"><CloseIcon /></button>
```

#### Missing Form Labels

```tsx
// ❌ Bad: Input without label
<input type="text" placeholder="Enter name" />

// ✅ Good: Proper label association
<label htmlFor="name-input">Name</label>
<input id="name-input" type="text" />
```

---

## 4. Design Token Testing

### Token Verification

Design tokens are built from `tokens/design-tokens.json` and should be tested:

```bash
# Build tokens
npm run build:tokens

# Verify tokens are generated
ls tokens/build/css/variables.css
ls tokens/build/js/tokens.js
```

### Using Tokens in Stories

```tsx
export const TokenExample: Story = {
  render: () => (
    <div style={{
      backgroundColor: 'var(--ozean-licht-color-primary-500)',
      padding: 'var(--ozean-licht-spacing-4)',
      borderRadius: 'var(--ozean-licht-border-radius-lg)',
    }}>
      Using design tokens
    </div>
  ),
};
```

### Token Coverage

Ensure all components use tokens instead of hardcoded values:

```tsx
// ❌ Bad: Hardcoded values
<div className="bg-[#0ec2bc] p-4 rounded-lg">

// ✅ Good: Using tokens
<div className="bg-primary-500 p-4 rounded-lg">
```

---

## 5. Continuous Integration

### GitHub Actions Workflow

Our CI/CD pipeline runs:

1. **Install dependencies** - `npm ci`
2. **Build Storybook** - `npm run build-storybook`
3. **Run Chromatic** - Visual regression testing
4. **Generate reports** - PR status checks

### Required Secrets

Add to GitHub repository secrets:

- `CHROMATIC_PROJECT_TOKEN` - Chromatic project token

### CI Best Practices

1. **Keep builds fast**: TurboSnap only tests changed components
2. **Review failures promptly**: Visual changes should be reviewed within 24h
3. **Don't ignore warnings**: Accessibility violations should be fixed, not ignored

---

## 6. Testing Workflow

### Development Workflow

```bash
# 1. Start Storybook
npm run storybook

# 2. Write component story
# 3. Check accessibility panel (no violations)
# 4. Write portable story test
# 5. Run tests
npm test

# 6. Verify all tests pass
# 7. Commit changes
# 8. Push to GitHub (triggers Chromatic)
# 9. Review visual changes in Chromatic dashboard
# 10. Merge PR
```

### Pre-commit Checklist

Before committing component changes:

```markdown
- [ ] Story renders correctly in Storybook
- [ ] All story variants documented
- [ ] Accessibility panel shows no violations
- [ ] Portable story test written
- [ ] All tests pass (`npm test`)
- [ ] Design tokens used (not hardcoded values)
- [ ] Component documented in story
```

### Pre-merge Checklist

Before merging PR:

```markdown
- [ ] GitHub Actions workflow passed
- [ ] Chromatic visual regression review completed
- [ ] All accessibility checks passed
- [ ] Code review approved
- [ ] No console errors or warnings
```

---

## 7. Debugging Tests

### Debugging Vitest Tests

```bash
# Run specific test file
npm test Button.test.tsx

# Run tests in watch mode with filter
npm test -- --watch Button

# Debug with VSCode
# Add breakpoint, use "JavaScript Debug Terminal"
```

### Debugging Visual Regressions

1. **Compare snapshots** in Chromatic dashboard
2. **Check for unintentional changes** (animations, timing)
3. **Review browser differences** (cross-browser inconsistencies)
4. **Update baselines** if changes are intentional

### Common Issues

#### Tests failing in CI but passing locally

- Check Node.js version consistency
- Verify dependencies are locked (`package-lock.json`)
- Clear cache: `npm ci` (clean install)

#### Visual snapshots differ unexpectedly

- Animation timing issues: Add `chromatic.delay`
- Font loading: Ensure fonts are loaded before snapshot
- Dynamic content: Use `chromatic.disableSnapshot` or mock data

#### Accessibility false positives

- Verify rule is appropriate for component
- Check if issue is in story setup vs component
- Document exceptions in story (if legitimate)

---

## 8. Resources

### Documentation

- [Vitest Documentation](https://vitest.dev/)
- [Testing Library](https://testing-library.com/docs/react-testing-library/intro/)
- [Chromatic Documentation](https://www.chromatic.com/docs/)
- [WCAG 2.1 Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)

### Internal Docs

- [Getting Started](/?path=/docs/introduction-getting-started--docs)
- [Component Guidelines](/?path=/docs/introduction-component-guidelines--docs)
- [Design Tokens](/?path=/docs/introduction-design-tokens--docs)

### Tools

- **@storybook/test** - Testing utilities for Storybook
- **@testing-library/react** - React component testing
- **@testing-library/user-event** - User interaction simulation
- **happy-dom** - Fast DOM implementation for tests
- **Chromatic** - Visual regression testing platform

---

## 9. FAQ

### When should I write unit tests vs rely on Chromatic?

- **Unit tests**: Component logic, state management, edge cases
- **Chromatic**: Visual appearance, layout, styling

Both are complementary and should be used together.

### How do I skip accessibility checks for a specific story?

```tsx
export const LegacyComponent: Story = {
  parameters: {
    a11y: {
      disable: true, // Only use for legacy components being phased out
    },
  },
};
```

**Note**: Avoid disabling a11y checks. Fix violations instead.

### How often should I accept Chromatic baselines?

Accept baselines when:
- Visual changes are intentional
- New features are added
- Design tokens are updated

Reject baselines when:
- Changes are unexpected
- Regressions are detected

### Can I test interactions in Chromatic?

Yes! Use the `@storybook/addon-interactions` with `play` functions:

```tsx
import { userEvent, within } from '@storybook/test';

export const InteractiveTest: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    const button = canvas.getByRole('button');
    await userEvent.click(button);
    // Chromatic will snapshot after interactions
  },
};
```

---

**Version**: 1.0.0 (Phase 3 Complete)
**Last Updated**: 2025-11-12
**Maintained by**: Ozean Licht Platform Team
